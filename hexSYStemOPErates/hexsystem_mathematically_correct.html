<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>hexSYStemOPErates - Mathematically Correct</title>
<style>
  body { 
    margin: 0; 
    background: #000; 
    color: #fff; 
    font-family: monospace; 
    display: flex; 
    height: 100vh; 
  }
  
  #mathematics { 
    width: 40%; 
    padding: 20px; 
    background: #111; 
    overflow-y: auto; 
  }
  
  #projection { 
    width: 60%; 
    background: #000; 
  }
  
  svg { 
    width: 100%; 
    height: 100%; 
  }
  
  .node { 
    fill: rgba(255,255,255,0.6); 
  }
  
  .link { 
    stroke: rgba(255,255,255,0.4); 
    stroke-width: 1; 
  }
  
  .high { opacity: 0.9; filter: blur(0.2px); }
  .mid { opacity: 0.5; filter: blur(0.8px); }
  .low { opacity: 0.2; filter: blur(1.5px); }
  
  .mathematical-state {
    background: #222;
    padding: 10px;
    margin: 10px 0;
    border-left: 3px solid #0f0;
  }
</style>
</head>
<body>

<div id="mathematics">
  <h2>Mathematical State</h2>
  
  <div class="mathematical-state">
    <h3>Hexagonal Topology H</h3>
    <div id="topology-state">Projected</div>
  </div>
  
  <div class="mathematical-state">
    <h3>Relation Conditions</h3>
    <div id="relation-state">Active</div>
  </div>
  
  <div class="mathematical-state">
    <h3>Visibility Mapping V(d)</h3>
    <div id="visibility-state">Structural</div>
  </div>
  
  <div class="mathematical-state">
    <h3>Projection P: H → DOM</h3>
    <div id="projection-state">Operational</div>
  </div>
</div>

<div id="projection">
  <svg id="field"></svg>
</div>

<script>
/* ========== MATHEMATICAL CONSTANTS ========== */
const HEX_RADIUS = 60;
const MAX_DISTANCE = 120;
const TOPOLOGY_ROWS = 6;
const TOPOLOGY_COLS = 8;

/* ========== VISIBILITY MAPPING (NON-DECISIONAL) ========== */
const VISIBILITY_STRUCTURE = [
  { threshold: 40, classification: "high" },
  { threshold: 80, classification: "mid" },
  { threshold: Infinity, classification: "low" }
];

function mapVisibility(distance) {
  return VISIBILITY_STRUCTURE.find(v => distance < v.threshold).classification;
}

/* ========== HEXAGONAL COORDINATE FUNCTIONS ========== */
function hexagonalPosition(q, r) {
  return {
    x: HEX_RADIUS * (3/2 * q),
    y: HEX_RADIUS * (Math.sqrt(3) * (r + q/2)),
    q: q,
    r: r
  };
}

function euclideanDistance(a, b) {
  return Math.sqrt((a.x - b.x)**2 + (a.y - b.y)**2);
}

/* ========== TOPOLOGY GENERATION ========== */
function generateTopology() {
  const nodes = [];
  for (let r = 0; r < TOPOLOGY_ROWS; r++) {
    for (let q = 0; q < TOPOLOGY_COLS; q++) {
      nodes.push(hexagonalPosition(q, r));
    }
  }
  return nodes;
}

/* ========== PROJECTION FUNCTION P: H → DOM ========== */
const svg = document.getElementById('field');
let domNodes = [];

function project() {
  // Clear previous projections
  svg.querySelectorAll('.link').forEach(link => svg.removeChild(link));
  
  // Generate topology nodes (if not present)
  const topology = generateTopology();
  
  // Project nodes (once only)
  if (domNodes.length === 0) {
    topology.forEach(node => {
      const circle = document.createElementNS("http://www.w3.org/2000/svg", "circle");
      circle.setAttribute("cx", node.x);
      circle.setAttribute("cy", node.y);
      circle.setAttribute("r", 4);
      circle.classList.add("node");
      svg.appendChild(circle);
      domNodes.push(circle);
    });
  }
  
  // Project relations (R conditions applied directly, no storage)
  for (let i = 0; i < topology.length; i++) {
    for (let j = i + 1; j < topology.length; j++) {
      const distance = euclideanDistance(topology[i], topology[j]);
      
      // Relation condition R[i,j] = 1 iff distance ≤ MAX_DISTANCE
      // No matrix storage - direct evaluation
      if (distance <= MAX_DISTANCE) {
        const line = document.createElementNS("http://www.w3.org/2000/svg", "line");
        line.setAttribute("x1", topology[i].x);
        line.setAttribute("y1", topology[i].y);
        line.setAttribute("x2", topology[j].x);
        line.setAttribute("y2", topology[j].y);
        line.classList.add("link");
        
        // Visibility mapping V(d) applied structurally
        line.classList.add(mapVisibility(distance));
        
        svg.appendChild(line);
      }
    }
  }
}

/* ========== CYCLIC RE-PROJECTION (NO TIME AUTHORITY) ========== */
function cyclicOperation() {
  project(); // P(H) idempotent operation
  requestAnimationFrame(cyclicOperation); // Repetition without temporal logic
}

// Initialize system
cyclicOperation();

/* ========== NO INVARIANT MONITORING ========== */
// Per mathematical definition: non-projection is natural error correction
// No active verification needed - structural compliance is inherent

</script>

</body>
</html>