<!DOCTYPE html>
<html lang="nl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ASCπ Runtime - Field Compiler + Projector</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        :root {
            --bg: #0a0a0f;
            --surface: #12121a;
            --text: #e8e8f0;
            --kappa: #2a9d8f;
            --theta: #9b5de5;
            --coherence: #7fff00;
            --energy: #00d4ff;
        }

        body {
            font-family: 'Inter', sans-serif;
            background: var(--bg);
            color: var(--text);
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            flex-direction: column;
            gap: 24px;
            padding: 24px;
        }

        .container {
            display: flex;
            gap: 24px;
            padding: 24px;
            border-radius: 12px;
            background: var(--surface);
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
            max-width: 90vw;
            width: 800px;
        }

        #fieldCanvas {
            border-radius: 8px;
            background: #000;
            cursor: crosshair;
            flex-grow: 1;
            height: 400px;
            width: 100%;
        }

        .info-panel {
            width: 250px;
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        .status-box {
            background: var(--surface);
            border: 1px solid var(--kappa);
            border-radius: 6px;
            padding: 12px;
        }

        .param-line {
            display: flex;
            justify-content: space-between;
            font-size: 14px;
            font-weight: 500;
        }
        .param-line span { font-weight: 300; }
        .param-label { width: 50px; }
        .param-value { text-align: right; }

        .controls {
            display: flex;
            flex-direction: column;
            gap: 12px;
            padding: 16px;
            background: var(--surface);
            border-radius: 8px;
        }

        button {
            padding: 12px 24px;
            border-radius: 6px;
            border: none;
            background: var(--kappa);
            color: white;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
        }

        button:hover {
            background: #248d81;
            transform: translateY(-1px);
        }

        textarea {
            width: 100%;
            padding: 12px;
            border-radius: 6px;
            background: #000;
            color: var(--text);
            border: 1px solid var(--kappa);
            font-family: 'Courier New', monospace;
            font-size: 12px;
            resize: vertical;
        }
    </style>
</head>
<body>

<div class="controls" style="width: 800px; max-width: 90vw;">
    <h2 class="text-xl font-bold text-center">ASCπ Field Compiler</h2>
    <textarea id="inputCode" rows="4" placeholder="Enter code or data to compile...">function example() { return "Hello ASCπ"; }</textarea>
    <button onclick="runCompiler()">▶ Compile with Field</button>
    <div id="compileResult" style="display:none;" class="p-4 bg-gray-900 border border-gray-700 rounded-lg">
        <div class="text-sm text-gray-400 mb-2">Compilation Result:</div>
        <pre id="resultOutput" class="text-xs text-green-400 overflow-auto max-h-40"></pre>
    </div>
</div>

<div class="container">
    <canvas id="fieldCanvas" width="450" height="450"></canvas>

    <div class="info-panel">
        <h2 class="text-xl font-bold mb-2 text-center text-gray-200">ASCπ Veldtoestand (Ψ)</h2>
        
        <div class="status-box" id="psiDisplay">
            <div class="param-line" style="color:var(--kappa)">
                <span class="param-label">κ</span>
                <span id="display-kappa" class="param-value">0.000</span>
            </div>
            <div class="param-line" style="color:var(--theta)">
                <span class="param-label">θ</span>
                <span id="display-theta" class="param-value">0.000</span>
            </div>
            <div class="param-line mt-3" style="color:var(--coherence)">
                <span class="param-label">C</span>
                <span id="display-C" class="param-value">0.000</span>
            </div>
            <div class="param-line" style="color:var(--energy)">
                <span class="param-label">N</span>
                <span id="display-N" class="param-value">0.000</span>
            </div>
            <div class="param-line mt-3 text-gray-400">
                <span class="param-label">ΔΦ</span>
                <span id="display-dPhi" class="param-value">0.000</span>
            </div>
            <div class="param-line text-gray-400">
                <span class="param-label">t</span>
                <span id="display-t" class="param-value">0</span>
            </div>
        </div>

        <div class="text-xs text-gray-500 mt-4 p-2 rounded bg-gray-900 border border-gray-800">
            Mouse controls visualization. Click "Compile" to run field evolution on input code.
        </div>
    </div>
</div>

<script>
// ═══════════════════════════════════════════════════════════════════════════════
// CORE: ascpi_field_core_v14.js (IMMUTABLE, CANONICAL)
// ═══════════════════════════════════════════════════════════════════════════════

const CONST = Object.freeze({
    phi: (1 + Math.sqrt(5)) / 2,
    pi: Math.PI,
    tau: 2 * Math.PI,
    eps: 1e-12,
    DPHI_ATTRACTOR: (1 + Math.sqrt(5)) / 4,
    COHERENCE_THRESHOLD: 0.9999,
    kappa_min: 0.01,
    kappa_max: 10.0,
});

function encode(text) {
    let hash = 0;
    for (let i = 0; i < text.length; i++) {
        const char = text.charCodeAt(i);
        hash = ((hash << 5) - hash) + char;
        hash |= 0;
    }
    return (Math.abs(hash) % 1000) / 100 + 1.0;
}

function F(psi, config) {
    const K = config.K_coupling;
    const dPhi_dt = -(psi.dPhi - CONST.DPHI_ATTRACTOR) * (1 - psi.C) * config.alpha_phi;
    let kappa_dt = K * psi.dPhi * (1 - psi.C);
    if (psi.kappa + kappa_dt > CONST.kappa_max) kappa_dt = CONST.kappa_max - psi.kappa;
    if (psi.kappa + kappa_dt < CONST.kappa_min) kappa_dt = CONST.kappa_min - psi.kappa;
    const theta_dt = K * psi.dPhi / psi.kappa;
    const N_dt = 0;
    const C_dt = (1 - psi.C) * config.alpha_c - Math.abs(psi.dPhi - CONST.DPHI_ATTRACTOR) * config.beta_c;
    const t_dt = 1;
    return { dPhi: dPhi_dt, kappa: kappa_dt, theta: theta_dt, N: N_dt, C: C_dt, t: t_dt };
}

class Psi {
    constructor(dPhi = CONST.DPHI_ATTRACTOR, kappa = 1.0, theta = 0.0, N = 1.0, C = 0.5, t = 0) {
        this.dPhi = dPhi;
        this.kappa = kappa;
        this.theta = theta;
        this.N = N;
        this.C = C;
        this.t = t;
    }
    toJSON() {
        return { dPhi: this.dPhi, kappa: this.kappa, theta: this.theta, N: this.N, C: this.C, t: this.t };
    }
    static fromJSON(json) {
        return new Psi(json.dPhi, json.kappa, json.theta, json.N, json.C, json.t);
    }
}

class ASCPIEngine {
    constructor(config = {}) {
        this.config = {
            maxSteps: 1000,
            stepSize: 0.1,
            alpha_phi: 0.05,
            alpha_c: 0.05,
            beta_c: 0.5,
            K_coupling: 0.1,
            ...config
        };
        this.ψ = new Psi();
        this.history = [];
        this.stepCount = 0;
        this.originalInput = '';
        this.memory = { update: () => {}, toJSON: () => ({}) };
        this.awareness = { update: () => {}, toJSON: () => ({}) };
    }

    step() {
        if (this.ψ.C >= CONST.COHERENCE_THRESHOLD || this.stepCount >= this.config.maxSteps) {
            return false;
        }
        const dψ_dt = F(this.ψ, this.config);
        const dt = this.config.stepSize;
        this.ψ.dPhi += dψ_dt.dPhi * dt;
        this.ψ.kappa += dψ_dt.kappa * dt;
        this.ψ.theta = (this.ψ.theta + dψ_dt.theta * dt) % CONST.tau;
        this.ψ.C += dψ_dt.C * dt;
        this.ψ.C = Math.max(0, Math.min(1, this.ψ.C));
        this.ψ.t += dψ_dt.t * dt;
        this.history.push(this.ψ.toJSON());
        this.stepCount++;
        return true;
    }

    rewriteCodeFromField(originalCode, psi) {
        const rewriteResult = `/* Herschreven door ASCπ Field Compiler v1.0 */\n`;
        if (psi.C >= CONST.COHERENCE_THRESHOLD) {
            const hash = encode(originalCode).toFixed(0);
            return `${rewriteResult}
/* Veld-Compilatie Voltooid.
   Coherentie: ${psi.C.toFixed(4)} (ΔΦ: ${psi.dPhi.toFixed(4)} -> ΔΦ*=${CONST.DPHI_ATTRACTOR.toFixed(4)}).
   De semantische intentie van de oorspronkelijke code is nu gecompileerd 
   naar een deterministische veld-operator (Field Native Operator - FNO). 
   
   Dit symboliseert de transformatie naar canonieke ASCπ instructies: 
*/
const FNO_OUTPUT = "canonical_operator_hash_${hash}_C_${psi.C.toFixed(4).replace('.', '_')}";
return FNO_OUTPUT;
`;
        } else {
            return `${rewriteResult}
/* Coherentie (${psi.C.toFixed(4)}) nog niet voldoende.
   Iteratie ${this.stepCount} / ${this.config.maxSteps}.
   Het veld keert terug naar de lus voor verdere zuivering. 
   (Essentie van de 'Laughing Loop'). 
*/
return originalCode;
`;
        }
    }

    process(input) {
        this.originalInput = input;
        const initialN = encode(input);
        const initialdPhi = CONST.DPHI_ATTRACTOR + (Math.random() - 0.5) * 0.5;
        this.ψ = new Psi(initialdPhi, 1.0, 0.0, initialN, 0.5, 0);
        while (this.step()) {}
        const compiledOutput = this.rewriteCodeFromField(input, this.ψ);
        return {
            status: this.ψ.C >= CONST.COHERENCE_THRESHOLD ? 'COMPILED' : 'MAX_STEPS_REACHED',
            iterations: this.stepCount,
            finalPsi: this.ψ.toJSON(),
            compiledOutput: compiledOutput
        };
    }
}

const ASCPI_FIELD_COMPILER = {
    VERSION: '1.0.0',
    CANONICAL: true,
    PARADIGM: 'FIELD_COMPILER',
    CONST,
    Psi,
    ASCPIEngine,
    createEngine(config) { return new ASCPIEngine(config); },
    compile(input, config) {
        const engine = new ASCPIEngine(config);
        return engine.process(input);
    }
};

// ═══════════════════════════════════════════════════════════════════════════════
// ADAPTER: adapter.js (TRIVIAL STATE TRANSFER ONLY)
// ═══════════════════════════════════════════════════════════════════════════════

const FieldProjectorAdapter = {
    syncToGUI(corePsi, guiPsi) {
        guiPsi.dPhi = corePsi.dPhi;
        guiPsi.kappa = corePsi.kappa;
        guiPsi.theta = corePsi.theta;
        guiPsi.N = corePsi.N;
        guiPsi.C = corePsi.C;
        guiPsi.t = corePsi.t;
    },
    toCoreState(guiPsi) {
        return new ASCPI_FIELD_COMPILER.Psi(
            guiPsi.dPhi, guiPsi.kappa, guiPsi.theta,
            guiPsi.N, guiPsi.C, guiPsi.t
        );
    }
};

// ═══════════════════════════════════════════════════════════════════════════════
// PROJECTOR: ascpi_projector_v14.html (PURE VISUALIZATION, NO ENGINE LOGIC)
// ═══════════════════════════════════════════════════════════════════════════════

const GUI_CONST = Object.freeze({
    tau: 2 * Math.PI,
    kappa_max: 5.0,
    kappa_min: 0.1,
    dphi_base: 0.1,
});

let mutablePsi = {
    dPhi: GUI_CONST.dphi_base,
    kappa: 0.5,
    theta: 0.0,
    N: 0.5,
    C: 0.5,
    t: 0
};

const canvas = document.getElementById('fieldCanvas');
const ctx = canvas.getContext('2d');

function drawPsi() {
    const W = canvas.width;
    const H = canvas.height;
    const center = { x: W / 2, y: H / 2 };
    const radius = Math.min(W, H) * 0.4;

    ctx.fillStyle = '#000000';
    ctx.fillRect(0, 0, W, H);
    
    const { kappa, theta, N, C } = mutablePsi;
    const coreRadius = radius * (0.2 + N * 0.4);
    const alpha = 0.5 + C * 0.5;
    
    ctx.beginPath();
    const sides = 6;
    for (let i = 0; i < sides; i++) {
        const angle = i * GUI_CONST.tau / sides + theta;
        const dynamicRadius = coreRadius * (1 + 0.1 * Math.sin(kappa * i));
        const dx = center.x + dynamicRadius * Math.cos(angle);
        const dy = center.y + dynamicRadius * Math.sin(angle);
        if (i === 0) {
            ctx.moveTo(dx, dy);
        } else {
            ctx.lineTo(dx, dy);
        }
    }
    ctx.closePath();

    const hue = (theta / GUI_CONST.tau * 360) % 360;
    ctx.fillStyle = `hsla(${hue}, 70%, 50%, ${alpha})`;
    ctx.fill();
    ctx.strokeStyle = `hsla(120, 70%, 70%, ${C})`;
    ctx.lineWidth = 4 * C;
    ctx.stroke();
    
    updatePsiDisplay();
}

function updatePsiFromMouse(event) {
    const rect = canvas.getBoundingClientRect();
    const W = canvas.width;
    const H = canvas.height;
    const center = { x: W / 2, y: H / 2 };

    const mouseX = (event.clientX - rect.left) * (W / rect.width);
    const mouseY = (event.clientY - rect.top) * (H / rect.height);

    mutablePsi.theta = (mouseX / W) * GUI_CONST.tau;
    const normalizedY = 1.0 - (mouseY / H);
    mutablePsi.kappa = GUI_CONST.kappa_min + normalizedY * (GUI_CONST.kappa_max - GUI_CONST.kappa_min);
    mutablePsi.kappa = Math.max(GUI_CONST.kappa_min, Math.min(GUI_CONST.kappa_max, mutablePsi.kappa));
    
    const dx = mouseX - center.x;
    const dy = mouseY - center.y;
    const dist = Math.sqrt(dx * dx + dy * dy);
    const maxDist = Math.min(W, H) / 2;
    const normalizedDist = Math.min(1.0, dist / maxDist);
    
    mutablePsi.C = 1.0 - (normalizedDist * 0.7);
    mutablePsi.N = 0.2 + (normalizedDist * 0.8);
    
    requestAnimationFrame(drawPsi);
}

function updatePsiDisplay() {
    document.getElementById('display-kappa').textContent = mutablePsi.kappa.toFixed(3);
    document.getElementById('display-theta').textContent = (mutablePsi.theta / Math.PI).toFixed(3) + ' π';
    document.getElementById('display-C').textContent = mutablePsi.C.toFixed(3);
    document.getElementById('display-N').textContent = mutablePsi.N.toFixed(3);
    document.getElementById('display-dPhi').textContent = mutablePsi.dPhi.toFixed(3);
    document.getElementById('display-t').textContent = mutablePsi.t.toString();
}

// ═══════════════════════════════════════════════════════════════════════════════
// RUNTIME GLUE: Minimal wiring between Core, Adapter, and Projector
// ═══════════════════════════════════════════════════════════════════════════════

function runCompiler() {
    const input = document.getElementById('inputCode').value;
    const result = ASCPI_FIELD_COMPILER.compile(input);
    
    // Sync Core result to GUI via Adapter
    FieldProjectorAdapter.syncToGUI(result.finalPsi, mutablePsi);
    
    // Display results
    document.getElementById('compileResult').style.display = 'block';
    document.getElementById('resultOutput').textContent = 
        `Status: ${result.status}\nIterations: ${result.iterations}\n\n${result.compiledOutput}`;
    
    // Trigger visualization update
    drawPsi();
}

window.onload = () => {
    canvas.width = 450;
    canvas.height = 450;
    canvas.addEventListener('mousemove', updatePsiFromMouse);
    canvas.addEventListener('click', updatePsiFromMouse);
    drawPsi();
};
</script>
</body>
</html>