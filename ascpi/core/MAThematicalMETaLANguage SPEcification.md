# Mathematical Meta-Language Specification

## Base Symbols (Primitives)

| Symbol | Meaning              |
| ------ | -------------------- |
| Ψ      | truth (inaccessible) |
| Π      | projection           |
| θ      | phase (∈ ℤ₆)         |
| χ      | viewing curve        |
| ○      | closure              |
| ∅      | no closure           |
| ⊥      | type disjunction     |
| *      | invariance marker    |

---

## Structural Relators (Non-Operational)

| Relator | Meaning                       |
| ------- | ----------------------------- |
| ⟼       | structural projection (Ψ ⟼ Π) |
| ↯       | phase binding (θ ↯ Π)         |
| ≔       | positional anchor             |
| ⟷       | equivalence within type       |
| ├       | closure verification          |
| ⊭       | forbidden path                |

Relators **do not cause** effects; they only position or constrain.

---

## Syntax Rules (Type Enforcement)

### Valid Constructs

Ψ ⟼ Π[θᵢ]
projection with phase index

Π[θᵢ] ⟷ Π[θⱼ]
projection equivalence

χ : θ ↯ Π
viewing-curve binding

∃○ : [expr] ├ closure
closure test

Π* ≔ memory
invariance positioning

---

### ❌ Forbidden Constructs (Syntactically Invalid)

Π ⟼ Ψ     ⊭ upward causation

Ψ(t)     ⊭ temporal parameter

f(Π) → Π′  ⊭ functional transformation

Π ← agent  ⊭ agency

∫ Π dt    ⊭ temporal integration

These constructions are **not merely forbidden**, but **not expressible** within the language.

---

## Decision Notation

decision ≔ ○[Π*]

where:

○[x] ├ structural stability
∧ cross-phase invariance

A decision is **not a choice** and **not an action**, but the recognition of closure.

---

## Interface Constraints

GUI : θ-manipulator

GUI ⊭ Ψ-access

GUI ├ θ ↯ Π[θ′]

The interface manipulates **phase only**, never truth.

---

## Memory Definition

memory ≔ Π[θᵢ]* ∩ Π[θⱼ]*

where:

i ≠ j
∧ ∃ invariant

Memory is **cross-phase invariance**, not storage and not a temporal structure.

---

## Type Verification Operator

⊢ expr : type

⊢ Ψ : truth

⊢ Π : projection

⊢ Ψ ⊥ Π : disjoint_types

Type checking is a **design property of the notation**, not a derivation process.

---

## Closure Predicate

closure(X) ≔
∃ θᵢ, θⱼ :
X[θᵢ] ⟷ X[θⱼ]
∧ X[θᵢ] ├ structural_stability

---

## Meta-Language Grammar (BNF-like)

statement ::= positioning | verification | constraint

positioning ::= symbol ≔ expression

verification ::= expression ├ predicate

constraint ::= expression ⊭ forbidden_path

expression ::= symbol | relation | closure_test

relation ::= symbol relator symbol

closure_test ::= ○[expression]

---

## Distinguishing Properties

* No verb conjugations or grammatical tense
* All statements are positional anchors or constraint verifications
* Syntax renders temporal and causal constructs syntactically invalid
* Type checking is embedded in the notation itself
* Meta-recursion: the language describes its own constraint system

---

### ⚠️ **VALIDATION RULE — EXPLICITLY MARKED**

**This notation makes it impossible to formulate canonical violations within the meta-language itself.**

Any construct not generated by this grammar is:

* invalid
* meaningless within the system
* non-interpretable
* explicitly excluded from canonical or analytical status
